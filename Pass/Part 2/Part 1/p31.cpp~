#define DEBUG_TYPE "p31"
#include "llvm/Transforms/Scalar.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/Analysis/ConstantFolding.h"
#include "llvm/IR/Constant.h"
#include "llvm/IR/DataLayout.h"
#include "llvm/IR/Instruction.h"
#include "llvm/Pass.h"
#include "llvm/Support/InstIterator.h"
#include "llvm/Target/TargetLibraryInfo.h"
#include "llvm/Support/raw_ostream.h"
#include <set>

using namespace llvm;

namespace {
	
	struct p31 : public FunctionPass {
		// Pass identification, replacement for typeid
		static char ID; 
		p31() : FunctionPass(ID) {}

		//Run for each function
		virtual bool runOnFunction(Function &F){
			int changed;			

   			std::set<Instruction*> instructionList;	//List of instructions
			//Put each instruction into list			
			for(inst_iterator i = inst_begin(F), e = inst_end(F); i != e; ++i){
       				instructionList.insert(&*i);
   			}

			//Get necessary analysis for data folding
			DataLayout *DL = getAnalysisIfAvailable<DataLayout>();
			TargetLibraryInfo *TLI = &getAnalysis<TargetLibraryInfo>();

			//While still analyzing instructions
			while (!instructionList.empty()) {
				//Pull top most instruction
				Instruction *I = *instructionList.begin();
			     	instructionList.erase(instructionList.begin());
			 
				//If there is an actual instruction
			     	if (!I->use_empty()){    
					//Try folding and get value
					 errs()<<I<<" -     ";        
Constant *C = ConstantFoldInstruction(I, DL, TLI);
					 errs()<<C<<"\n";        
			       		if (Constant *C = ConstantFoldInstruction(I, DL, TLI)) {
					 errs()<<"asd\n";        
						//Get all instructions that refer to this value
						for (Value::use_iterator UI = I->use_begin(), UE = I->use_end(); UI != UE; ++UI){
				  			instructionList.insert(cast<Instruction>(*UI));
						}
			 
					 // Replace all instructions that refer to this value with constant
					 I->replaceAllUsesWith(C);
				 
					 // Remove the dead instruction.
					 instructionList.erase(I);
					 I->eraseFromParent();
				 
					 // Count changed
					 ++changed;

				       }
				}
			}
			
			return 1;

		}

		virtual void getAnalysisUsage(AnalysisUsage &AU) const {
			AU.setPreservesCFG();
			AU.addRequired<TargetLibraryInfo>();
		}

	};
}
char p31::ID = 0;
static RegisterPass<p31> X("p31", "Part 3.1", true, true);

